[["index.html", "BIO-6013A/7004A, Bioinformatics Skills I and II Chapter 1 Introduction 1.1 Getting started", " BIO-6013A/7004A, Bioinformatics Skills I and II Philip Leftwich, Ellen Bell, Douglas Yu 2023-09-22 Chapter 1 Introduction This is a very short introduction to some of the processes and tools we use when working in bioinformatics. This is not meant to be anywhere near comprehensive; you will be shown a few Unix fundamentals and one walk-through of a single bioinformatics task: using BLAST to identify DNA and One of the main differences between Bioinformatics and the data analysis you have done before is the size of the data. Bioinformatics usually deals with sequencing data, and this data has large file sizes. Handling big data means you need to know how to operate on a supercomputer so we will be learning a little bit of Linux, processing big data into small data and then exporting into R to make some more amazing data visuals and interpret our findings! Here we will start to build a bioinformatics skill set, using the command line. 1.1 Getting started These bioinformatics workshops will be run through RStudio Cloud, you will need to make a free account here and join the workspace BIO 6013A here. Once you have signed up you will see that you have two spaces; Your Workspace BIO 6013A Make sure you are in the class workspace. Open the project marked as blast_workshop Once you are in the workshop it should look something like this; Figure 1.1: Your blast workshop project in RStudio Cloud DON‚ÄôT worry if you don‚Äôt understand everything DO ask lots of questions! "],["Unix.html", "Chapter 2 Unix 2.1 What is Unix/Linux? 2.2 Why Learn Unix? 2.3 Getting started 2.4 A few foundational rules 2.5 Let‚Äôs get started 2.6 Unix File Structure 2.7 Absolute vs relative file paths 2.8 Moving around 2.9 Summary 2.10 Stretch yourself - optional extras to try a couple of other skills", " Chapter 2 Unix Unix is very likely the most fundamental skillset we can develop for bioinformatics (and much more than bioinformatics). Many of the most common and powerful bioinformatics approaches happen in this text-based environment, and having a solid foundation here can make everything we‚Äôre trying to learn and do much easier. This is a short introductory tutorial to help us get from being completely new to Unix up to being friendly with it üôÇ 2.1 What is Unix/Linux? UNIX is a computer operating system. It was first developed in 1969 at Bell Labs. Unix is written in the programming language C. Unix is proprietary software, whereas Linux is basically free and open-source Unix. The Linux Operating System is highly flexible, free, open-source (like R) and uses very little RAM to run (Unlike Windows OS) - as such you find most supercomputers run on Linux. Operationally Linux is almost identical to Unix, and so we often refer to it under the umbrella term of ‚Äúunix-like‚Äù systems. 2.1.1 Some terms Here are some terms worth knowing, don‚Äôt worry about memorising them, it can just be useful to have these to refer to in the future. Term What it is shell what we use to talk to the computer; anything where you are pointing and clicking with a mouse is a¬†Graphical¬†User¬†Interface (GUI) shell; something with text only is a¬†Command¬†Line¬†Interface (CLI) shell command line a text-based environment capable of taking input and providing output terminal A program that runs a shell Unix a family of operating systems (we also use the term ‚ÄúUnix-like‚Äù because one of the most popular operating systems derived from Unix is specifically named as¬†not¬†being Unix) Linux a ‚ÄúUnix-like‚Äù OS bash the most common programming language used at a Unix command-line flag a way to set options for a function, a specific type of argument usually preceded by a - Note You should be familiar with using a GUI (Windows and macOS are GUIs), but to program a computer, you need to use a CLI (command line interface). 2.2 Why Learn Unix? Most sequencing data files are large and require a lot of computer memory (RAM) to process. As a result most of the work that bioinformaticians do is not hosted on their own laptops or desktops. Instead, they ‚Äúremote-connect‚Äù to high performance supercomputers or cluster computers. Almost all of these high performance computers use ‚ÄúUnix-like‚Äù operating systems, the most common of which is Linux. As stated above, Linux is free and open-source so there are lots of developers. It‚Äôs also well known for being stable, secure, reliable, and efficient. Today, you will get some experience with using a Linux OS. By logging into posit.cloud you are connecting to a supercomputer that runs Linux, and on top of Linux, the company Posit makes it possible to run RStudio, which is a GUI for the statistics program called R. (Confusing? Yes. Linux is a CLI on which the GUI RStudio runs, so that it is easier to run the CLI R.) When you click on RStudio‚Äôs Terminal tab, it provides direct access to a command line where we can execute commands and functions directly in Linux. (yes, now you have gone from the Linux CLI to RStudio‚Äôs GUI back to the Linux CLI). This allows us to use programs other than R, and potentially use multiple programs &amp; programming languages to work together. Note This series of practicals is designed for you to have a first introduction to Bioinformatics. It‚Äôs about exposure, not memorising or mastering anything. Don‚Äôt worry about the details! 2.3 Getting started Before we get started we need a terminal to work in. Open the Bioinformatics RStudio Cloud Project in the BIO-6013A workspace Click on the Terminal tab next to Console in the bottom-left pane of the RStudio GUI, this opens a command-line Shell Figure 2.1: Here is an example of the Terminal tab, right next to the R console This is our ‚Äúcommand line‚Äù where we will be typing all of our commands. We type our commands in a language called bash The $ is where you start typing from, left of this it tells you what folder you are currently in (working directory) If you need to, you can exit the Terminal and start a new session easily with options in RStudio 2.4 A few foundational rules Spaces are special and break things apart. As a rule it is better to have functions and file names with dashes (-) or underscores (_) where you want space to be- e.g.¬†‚Äúdraft_v3.txt‚Äù is preferred to ‚Äúdraft v3.txt‚Äù. The general syntax on the command line is: command argument. This is very similar to R except we don‚Äôt use brackets e.g.¬†in R we are used to command(argument) Arguments can be optional e.g.¬†if their is a default argument you may not have to write anything. Some functions require that arguments are specified. Again this is just like R. 2.5 Let‚Äôs get started We will perform a very simple function and get a flavour of the similarities and differences to working in R. date is a command that prints out the date and time. Copy and paste this command into your terminal date This prints out the date/time in UTC Figure 2.2: It should look like this: More information on using the date function is here. We can also ask for the output for a particular timezone using the TZ function and date TZ=Europe/London date Or we can ask the computer what the date will be next Tuesday‚Ä¶ date --date=&quot;next tue&quot; Note how we use the command argument structure here. date is the command, and --date=\"next tue\" is the argument that causes the date command to modify its output. This argument is optional, as you have seen. Often, commands have required arguments. 2.5.1 Downloading data We will start by typing in an instruction to download data from an online data repository, unpack the contents and inspect it. curl is a command line tool for transferring data to and from a remote computer server. Here we will use this to download data from an online repository. tar will unpack the data from a compressed file format cd changes the directory so we land in the new folder we have made Use the copy icon in the top right of the code block to copy all 3 commands and paste them into the Terminal. If this seems onerous to you, you are right. There is a keyboard shortcut for sending commands to the terminal. On Macs, it is opt-cmd-enter. On Windows, you can find the shortcut by opening Tools/Keyboard Shortcuts Help/ and looking for Send to Terminal under the Execute submenu. curl -L -o unix_intro.tar.gz https://ndownloader.figshare.com/files/15573746 tar -xzvf unix_intro.tar.gz &amp;&amp; rm unix_intro.tar.gz cd unix_intro Check each command line has run, in the example above you might find that the first two lines run, to download and unpack data, while the last line to change directory doesn‚Äôt run until you hit enter 2.5.2 More functions Before the next step, make sure that you are in the unix_intro/ directory. You should see unix_intro$ in the command line. Unlike date, most commands require arguments and won‚Äôt work without them. head is a command that prints the first lines of a file, so it requires us to provide the file we want it to act on: head example.txt Here ‚Äúexample.txt‚Äù is the required argument, and in this case it is also what‚Äôs known as a positional argument. Whether things need to be provided as positional arguments or not depends on how the command or program we are using was written. Sometimes we need to specify the input file by putting something in front of it (e.g.¬†some commands will use the -i flag, but it‚Äôs often other things as well). Q. What‚Äôs in the text file? - Click here for Answer Pretty boring, each line contains the text ‚ÄúThis is line‚Äù followed by the line number e.g. - This is line 1 - This is line 2 etc. There are also optional arguments for the head command. The default for head is to print the first 10 lines of a file. We can change that by specifying the -n flag, followed by how many lines we want: head -n 20 example.txt How would we know we needed the -n flag for that? There are a few ways to find out. Many standard Unix commands and other programs will have built-in help menus that we can access by providing ‚Äìhelp as the only argument: head --help Well, at it happens, the command head does not have a help menu, but it still gives you some help when you try. Again this is very similar to the logic in which R commands are structured e.g.¬†?ggplot The syntax is similar even if the specific icons or arguments are different. Remember just like with R, one of your best friends is Google! As you get familiar with any language or OS we might remember a few flags or specific options, but searching for options and details when needed is definitely the norm! 2.6 Unix File Structure There are two special locations in all Unix-based systems: the ‚Äúroot‚Äù location and the current user‚Äôs ‚Äúhome‚Äù location. ‚ÄúRoot‚Äù is where the address system of the computer starts; ‚Äúhome‚Äù is usually where the current user‚Äôs location starts. Just to be awkward, Posit Cloud actually has us working in a different location ‚ÄúCloud‚Äù, which is underneath Root but separate to home which would be in the ‚ÄúUsers‚Äù folder. We tell the command line where files and directories are located by pre-pending the file name with the list of directories that hold them, known as the file‚Äôs ‚Äúpath‚Äù. If we use the pwd command (for print working directory), we can find out what the path is for the directory we are sitting in. Our working directory is also visible to the left of the $ in the command line pwd And if we use the ls -l command (for list), we can see what directories and files are in the current directory we are sitting in. (Note the -l argument) (also, try ls ‚Äìhelp) ls -l Note Why is it important to know this? Usually when you are working on a Unix-like environment there is no GUI (a click and point interface), and all commands have to be submitted through the terminal. So you have to get used to navigating directories with typed commands, and it‚Äôs useful to know what the standard hierarchy is and where you happen to be at any given moment. 2.7 Absolute vs relative file paths You should be used to these concepts from your work with R projects. There are two ways to specify the path (address) of the file we want to do something to: An absolute path is an address that starts from an explicitly specified location: usually the ‚Äúroot‚Äù / or the ‚Äúhome‚Äù ~/ location. (Side note, because we also may see or hear the term, the ‚Äúfull path‚Äù, is usually the absolute path that starts from the ‚Äúroot‚Äù /.) A relative path is an address that starts from wherever we are currently sitting (the working directory). For example, let‚Äôs look again at the head command we ran above: head example.txt What we are actually doing here is using a relative path to specify where the ‚Äúexample.txt‚Äù file is located. This is because the command line automatically looks in the current working directory if we don‚Äôt specify anything else about its location. We can also run the same command on the same file using an absolute path - note Posit Cloud has a slightly unique set-up in that we start from a folder called cloud: head /cloud/project/unix_intro/example.txt The previous two commands both point to the same file right now. But the first way, head example.txt, will only work if we are ‚Äúsitting‚Äù in the directory that holds that file, while the second way will work no matter where we happen to be in the computer. It is important to always think about where we are in the computer when working at the command line. One of the most common errors/easiest mistakes to make is trying to do something to a file that isn‚Äôt where we think it is. Let‚Äôs run head on the ‚Äúexample.txt‚Äù file again, and then let‚Äôs try it on another file: ‚Äúnotes.txt‚Äù: head example.txt head notes.txt Here the head command works fine on ‚Äúexample.txt‚Äù, but we get an error message when we call it on ‚Äúnotes.txt‚Äù telling us no such file or directory. If we run the ls command to list the contents of the current working directory, we can see the computer is absolutely right ‚Äì spoiler alert: it usually is ‚Äì and there is no file here named ‚Äúnotes.txt‚Äù. The ls command by default operates on the current working directory if we don‚Äôt specify any location, but we can tell it to list the contents of a different directory by providing it as a positional argument: ls ls experiment We can see the file we were looking for is located in the subdirectory called ‚Äúexperiment‚Äù. Here is how we can run head on ‚Äúnotes.txt‚Äù by specifying an accurate relative path to that file: head experiment/notes.txt 2.8 Moving around We can also move into the directory containing the file we want to work with by using the cd command (change directory). This command takes a positional argument that is the path (address) of the directory we want to change into. This can be a relative path or an absolute path. Here we‚Äôll use the relative path of the subdirectory, ‚Äúexperiment‚Äù, to change into it cd experiment/ pwd ls head notes.txt Great. But now how do we get back ‚Äúup‚Äù to the directory above us? One way would be to provide an absolute path, like cd /cloud/project/unix_intro, but there is also a handy shortcut. .. which are special characters that act as a relative path specifying ‚Äúup‚Äù one level ‚Äì one directory ‚Äì from wherever we currently are. So we can provide that as the positional argument to cd to get back to where we started: cd .. Moving around the computer like this might feel a bit cumbersome and frustrating at first, but after spending a little time with it, you will get used to it, and it starts to feel more natural. Note One way to speed things up is to start using tab to perform tab-completion often this will auto-complete file names! Press tab twice quickly and it will print all possible combinations. 2.9 Summary While maybe not all that exciting, these commands really are the foundation needed to start utilizing the command line ‚Äì which then gives us the capability to use lots of tools that only work at a command line, manipulate large files rapidly access and work with remote computers, and more! These are the fundamental tools that every scientist needs to work with big data. 2.9.1 Terms Term What it is path the address system the computer uses to keep track of files and directories root where the address system of the computer starts,¬†/ home where the current user‚Äôs location starts,¬†~/ absolute path an address that starts from a specified location, i.e.¬†root, or home relative path an address that starts from wherever we are tab-completion our best friend 2.9.2 Commands Command What it is date prints out information about the current date and time head prints out the first lines of a file pwd prints out where we are in the computer (print¬†working¬†directory) ls lists contents of a directory (list) cd change¬†directories 2.9.3 Special characters Command What it is Characters Meaning / the computer‚Äôs root location ~/ the user‚Äôs home location ../ specifies a directory one level ‚Äúabove‚Äù the current working directory In a single session, you won‚Äôt get used to operating in bash, or moving around directories using just the command line. So if you think you are interested in developing your bioinformatic skills, spend some time practising. Here is a link to a couple of extended tutorials you can bookmark if you want to explore this further: https://datacarpentry.org/shell-genomics/index.html 2.10 Stretch yourself - optional extras to try a couple of other skills 2.10.1 Creation I want to create a new directory to store some code files I‚Äôm going to write later, so I‚Äôll use mkdir to create a new directory called Code: Check you are in the unix_intro folder - Click here for Answer pwd Make a new directory called Code - Click here for Answer mkdir Code Check this folder has been created using a list function ls Note that I used a relative file path to create the Code directory - but I could have also specified an absolute filepath to generate that folder in whatever location I want. There are a few ways to make new files on the command line. The simplest is to generate a blank file with the touch command followed by the path (relative or absolute) to the file you want to create Make a new file called data-science-class.txt - Click here for Answer touch data-science-class.txt ls -l Note here I could just use ls to list all files and folders in a directory, but if i set the flag -l then it will produce a long list of files. If the entry in the first column is a d, then the row in the table corresponds to a directory, otherwise the information in the row corresponds to a file. The string of characters following the d in the case of a directory or following the first - in the case of a file represent the permissions for that file or directory - I won‚Äôt cover that here - but some of the links I provide go into more detail. "],["BLAST.html", "Chapter 3 BLAST 3.1 Directories and their structure 3.2 File types 3.3 Basic Local Alignment Search Tool (BLAST) 3.4 Formative quiz 3.5 Before you leave", " Chapter 3 BLAST Lets take a moment to review some terminology. Unix - An operating system analogous with Windows. Shell - This is the interface we use to talk to the computer. If we are able to use the mouse to point and click we are using a Graphical User Interface (GUI). If we are only using text we are using a Command Line Interface (CLI). We will be using a CLI in these workshops. Command-line and Terminal - A text-based environment for sending commands to a computer‚Äôs operating system or to an application. The terminal is the app that gives you access to the operating system‚Äôs command line. It‚Äôs called terminal because there literally used to be a tv screen at the end (terminus) of a cable from a mainframe computer. bash - a programming language used to run a series of Unix commands and programs that run on Unix. Bash scripts can be used to automated large amounts of bioinformatic work, and are known as pipelines. Make sure that the the tab in the left panel is set to Terminal and NOT Console. You will be running commands in the Terminal. 3.1 Directories and their structure Working with text-based interfaces, where you are writing and running commands, means that we need to have some understanding of how files are organised within directories (‚Äúfolders‚Äù) and why it‚Äôs important to know which directory you are working in. Basically, you cannot open a file by pointing at it in a window. You need to write down the address to the file, which is known as the file‚Äôs path. To do that, you need to have a starting point for the path. Under Files in the bottom right panel of your screen you will see a file with the ending .Rproj. This is an R project file which tells R your starting point for navigating directories. It means that R will automatically treat the directory with the .Rproj file as the working directory. If you wish to access files outside of the working directory, you need to tell the program the file path that to the file(s). Look at the top of the File panel. You will Figure 3.1: The current directory in this image is /Cloud/project/images/, where the final / indicates that images/ is a directory, not a file. In Posit.cloud, /cloud is the ‚Äòroot‚Äô directory. If a file‚Äôs path is written out all the way from the root, it is known as the absolute path, e.g.¬†/cloud/project/images/ascii.png 3.1.1 Moving around folders/directories Look in the ‚Äòfiles‚Äô tab in the panel to the bottom right. You should have three folders stored there, called; data plots project_setup You can move around folders/directories in the command line, and it‚Äôs good to be comfortable doing this. Make sure you are in the Terminal tab in the panel to the bottom left and go to the /cloud/project directory with the cd command. (cd is shorthand for change directory, and remember to hit enter). cd /cloud/project Because we use /cloud/ at the beginning, we are using the absolute path to the project/ directory. Now list the files in this directory. ls -lF The ls command is shorthand for list, the -l argument means long listing format, and the -F argument means to classify the items by their type. Unix allows you to combine arguments into a single thing, to speed up typing. So ls -l -F is usually written as ls -lF. In fact, one way to think about Unix is that the commands are designed by people who like to use the command line but hate the act of typing, so all the commands are very short. If you get good at Unix, you will become like this. The terminal should return something that looks like this, and you will see that code/ and data/ are directories (because of the forward slashes). /cloud/project$ ls -lF total 12 drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 07:07 code/ drwxrwx--- 6 r574796 rstudio-user 4096 Sep 22 06:56 data/ -rw-rw-r-- 1 r574796 rstudio-user 205 Sep 22 11:07 project.Rproj Let‚Äôs go and have a look at the files held within data. Use following command; cd data/ now use ls -lF The terminal should return something that looks like this, showing four subdirectories underneath the data/ directory (which is itself a subdirectory of project/ /cloud/project/data$ ls -lF total 16 drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 blast/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 databases/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 query/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 refseq/ So you can see that you can use commands like ls and cd to move around your directories. Note - if you want to move back up a directory level you can use cd .. to do so. .. means up, and you can see the two dots at the top of the file list in the Files panel. If you click on those two dots, you also move up a directory level. Use cd, ls and cd .. to explore the directories available to you in your project. 3.1.2 Paths So hopefully you are getting comfortable moving between directories in the terminal. Here I will briefly introduce you to paths. Type in the following so that everyone is in the same location; cd /cloud/project/ If you want to enter some commands from this location that use the mouse.1.protein.faa file stored in the refseq directory you will need to provide a path for the location that file. These paths can either be absolute or relative. Relative paths provide a pathway from your current directory (in this case /cloud/project/). So to get to the directory where your mouse.1.protein.faa file is you could use the following path; data/refseq However if you are already in the databases directory, this path wont work because your computer will be looking for directories it cant see. This is where absolute paths come in useful. Absolute paths specify the location of a file or directory in relation to your root directory / (the top most directory in a hierarchy). So it doesn‚Äôt matter which directory you are currently in, the pathway will work. In this case the absolute path would be; /cloud/project/data/refseq Have a go at using both absolute and relative paths with the cd command to move around your directories. 3.2 File types When we look at sequence data there are a number of file types that you will regularly come into contact with. The most common of these are .fastq and .fasta files. Here we will have a look at some key features and differences of these file types. Fastq files are used as a data storage file for the output from Illumina sequencers. The structure of a .fastq file is very uniform, each DNA sequence has four lines dedicated to it. Line 1 - begins with an ‚Äò@‚Äô character and is followed by an identifier and optional description. For example it may contain information about the sequencer, the flow cell, index number etc. The identifier is unique to each sequence. Line 2 - is the DNA sequence Line 3 - a ‚Äò+‚Äô character (and sometimes a repeat of line 1) Line 4 - computer readable information relating to the quality for the sequence in line 2. There is the same number of characters as the sequence. The letters indicate the probability of error and are known as phred scores, coded as ASCII characters An example of three sequences from an Illumina sequencer in .fastq format is shown below. The A phred score translates to a phred score of 32, which means that the there is a 1/1585 probability that the nucleotide G is incorrect. @NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT GCATGTCTCTAGTTCCGGAACCAAAATCTCCTCCACCCACTCTGCGTCCTGCTGACTATAGGAGATAAAGGCGTCATAGCAGAGGGTGGCGCCTCCTTGGTGCACCGCCGGCTTTCGCTTCGCCTTAAACCAGGCGACGGACATTTTCAGG + AAAAAEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEAEEEEEEEEEAEEEEEEEEEEEEEEAAEEEEEEEEEAAEE&lt;AEEEEEEEEEEEEEEEEEEAEEEEEEE&lt;EA @NB501793:9:H77L2BGX2:1:11101:24170:10019 1:N:0:ATCACGAT GCATGTCAACATCATTCTTGTTTTGTTAGAGCCACTACCTACATATCTTATCCCTTCCAAGTACTACCAGCTAAAGGCAATGATACATGC + AAAAAEA/EEEE/EEEEEEEEEEEAEEEEEEEEEEEEEEEEEEEEEAEAEAEEEAEEEEEEEEEEEEEEAEEE/EEEEEEAE/E/AEEAE @NB501793:9:H77L2BGX2:1:11101:7027:14110 1:N:0:ATCACGAT GCATGTGATGTTGTGTTTTTGTACTCTCCTCTCACTTTGTCCAAAGTGAGTGGTGTCATTATGAGTTGTATTTTGCTAACCACCAGAGACTAACACGAGGGCTGGACAACATCATTCTAGTTTTGTTAGAGCCACTACCTACATATC + AAA/AEEEEEEEEEEEEEEEEAEAAEEEEAAEEEEEEE/EEEAEEEEA/EE6EEEEEEEEEEEE6EE/EAEEE/EEEAAEAEEE/EEEEEE6EEEAE/&lt;EAEEEEEE/EEAEEAE&lt;E//AE&lt;&lt;/EAEA//&lt;&lt;&lt;A6AE/EEEE/A/EA Fasta files are a simpler (and thus smaller) text-based file format for representing both nucleotide and amino acid sequences. These can be produced from .fastq files (but fastq files cannot be produced from fasta files). Each sequence in .fasta format comes with a header line which is marked by a ‚Äò&gt;‚Äô character prefix. Information following the ‚Äò&gt;‚Äô typically contains a sequence identifier and optional description of the sequence. An example of three sequences from an Illumina sequencer in .fasta format is shown below, you may notice that these are the same sequences as shown above in the .fastq example; typically, the header lines in fasta files are more human-readable (i.e.¬†not &gt;NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT) &gt;NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT CTCTAGTTCCGGAACCAAAATCTCCTCCACCCACTCTGCGTCCTGCTGACTATAGGAGATAAAGGCGTCATAGCAGAGGGTGGCGCCTCCTTGGTGCACCGCCGGCTTTCGCTTCGCCTTAAACCAGGCGACGGACATTTTCAGG &gt;NB501793:9:H77L2BGX2:1:11101:24170:10019 1:N:0:ATCACGAT CAACATCATTCTTGTTTTGTTAGAGCCACTACCTACATATCTTATCCCTTCCAAGTACTACCAGCTAAAGGCAATGATACATGC &gt;NB501793:9:H77L2BGX2:1:11101:7027:14110 1:N:0:ATCACGAT GATGTTGTGTTTTTGTACTCTCCTCTCACTTTGTCCAAAGTGAGTGGTGTCATTATGAGTTGTATTTTGCTAACCACCAGAGACTAACACGAGGGCTGGACAACATCATTCTAGTTTTGTTAGAGCCACTACCTACATATC Now, let‚Äôs have a look at your data. The /cloud/project/data/refseq directory contains files downloaded from the NCBI Reference Sequence project. These files comprise a set of transcript and protein sequences for the mouse and zebrafish model systems and were downloaded from the NCBI. Use your newfound command line tools to move into the refseq directory. When you run ls -lFh you should see the following: Figure 3.2: Using the extra argument -h makes the file sizes human readable. Use the head command to have a look at the first few lines of each of the four files stored in refseq. An example of the head command‚Äôs usage is as follows; head mouse.1.protein.faa What differences do you notice about the four files? Do you think these are .fastq or .fasta files? You might have noticed that there are two file suffixes (or file extensions): .faa and .fna. These file extensions can tell you something about the content of the file. Can you work out what these file extensions might be telling you? That ends our review of Unix. Now let‚Äôs do something bioinformatics-y! 3.3 Basic Local Alignment Search Tool (BLAST) The acronym BLAST stands for Basic Local Alignment Search Tool, it is a very versatile and useful program, frequently used in bioinformatic analysis. In essence it compares nucleotide or protein sequences to a database and uses statistics to calculate the significance of the similarities between hits. It has a range of uses; including assisting in the identification of sequences and assessing evolutionary relationships between sequences. There are different types of BLAST that work with nucleotide or amino acid input sequences. You have probably uploaded sequences to the NCBI website and used their BLAST tool from a web browser before, this can compare your query sequence against the entirety of GenBank. Here we will be looking at how to run BLAST from the command line against a local database. 3.3.1 Making a BLAST database In order to run BLAST we will need to make some suitable BLAST databases. Initially we will be using sequences from our mouse refseq files as queries to blast against databases made from our zebrafish refseq files. So lets convert our refseq zebrafish files into blast databases. Run the following command in the terminal; makeblastdb -in /cloud/project/data/refseq/zebrafish.1.rna.fna -dbtype nucl -out /cloud/project/data/databases/zebrafish.1.rna Take a moment to break down this command. You are essentially calling a function makeblastdb, you have told it which files you want to input using -in pathway/file and told it where this file is located via the path. You have also given instructions on what type of database you wish to produce (i.e.¬†a nucleotide database) using -dbtype nucl and given instructions on where you want this database to be stored using -out pathway/file_prefix. Use the cd and ls commands to go to /cloud/project/data/databases/. Have a look at the new files stored there. There should be three and they should have .nhr, .nin, .nsq file extensions. Now try and make a similar data base for the zebrafish.1.protein.faa refseq file. You will need to instruct makeblastdb to make a prot (protein) database instead of a nucl database. Check your results in /cloud/project/data/databases/. Once again there should be three files and they should have .phr, .pin and .psq file extensions. 3.3.2 Finding a query So hopefully you have a protein and nucleotide database prepared. Now we need to find a suitable query. We could use an entire mouse refseq file. But that would take a long time. Lets take a single entry from the mouse protein refseq file instead. To do this in the command line we can use awk, this is a scripting language used for the manipulation of data. In bioinformatics it is frequently used for filtering sequence files. For now, I would like you to use the awk command below, this will copy lines 5 and 6 of the mouse.1.protein.faa file and paste them in a new file called mouse.1.protein.1.faa in the query directory. awk &#39;NR==5 , NR==6&#39; /cloud/project/data/refseq/mouse.1.protein.faa &gt; /cloud/project/data/query/mouse.1.protein.1.faa Use head to look at the contents of the mouse.1.protein.1.faa file in the query directory. Hopefully it should look something like this; &gt;YP_220552.1 cytochrome c oxidase subunit I (mitochondrion) [Mus musculus domesticus] MFINRWLFSTNHKDIGTLYLLFGAWAGMVGTALSILIRAELGQPGALLGDDQIYNVIVTAHAFVMIFFMVMPMMIGGFGNWLVPLMIGAPDMAFPRMNNMSFWLLPPSFLLLLASSMVEAGAGTGWTVYPPLAGNLAHAGASVDLTIFSLHLAGVSSILGAINFITTIINMKPPAMTQYQTPLFVWSVLITAVLLLLSLPVLAAGITMLLTDRNLNTTFFDPAGGGDPILYQHLFWFFGHPEVYILILPGFGIISHVVTYYSGKKEPFGYMGMVWAMMSIGFLGFIVWAHHMFTVGLDVDTRAYFTSATMIIAIPTGVKVFSWLATLHGGNIKWSPAMLWALGFIFLFTVGGLTGIVLSNSSLDIVLHDTYYVVAHFHYVLSMGAVFAIMAGFVHWFPLFSGFTLDDTWAKAHFAIMFVGVNMTFFPQHFLGLSGMPRRYSDYPDAYTTWNTVSSMGSFISLTAVLIMIFMIWEAFASKREVMSVSYASTNLEWLHGCPPPYHTFEEPTYVKVK Note that the refseq .fasta file has been formatted so that each entry has two lines, one for header, one for sequence. This means that we are able to simply pull out sequence entries based on line number. Odd numbered lines will be headers and even numbered lines will be sequences. 3.3.3 BLASTp Now that we have prepared a query and database we can start to run some BLASTs. We have our query is from the protein refseq files, so we will run a BLASTp against the protein zebrafish database. Try running the following command; blastp -query /cloud/project/data/query/mouse.1.protein.1.faa -db /cloud/project/data/databases/zebrafish.1.protein -out /cloud/project/data/blast/mouse.1.protein.x.zebrafish.txt Take a look at the default output from this BLAST search, use: less /cloud/project/data/blast/mouse.1.protein.x.zebrafish.txt Type Enter to scroll through the file and q when you‚Äôre ready to quit. You will see that this defaut output contains a lot of information, including information relating to significant database hits, significance scores and alignments. We only have three hits here, so its easy enough to process in this format, but sometimes you may have much larger outputs, in this case a tabular format is much more desirable. Try running the following command; blastp -query /cloud/project/data/query/mouse.1.protein.1.faa -db /cloud/project/data/databases/zebrafish.1.protein -out /cloud/project/data/blast/mouse.1.protein.x.zebrafish.2.tsv -outfmt 6 Use less to have a look at this new presentation of information. This is a tabular format, which is much easier to process quickly especially when you are looking at large data sets. I have pasted the output you should be looking at below with the column headers added. You can read all about output format 6 here. qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore YP_220552.1 NP_059333.1 88.132 514 61 0 1 514 1 514 0.0 877 YP_220552.1 XP_021326074.1 31.818 66 32 2 427 482 16 78 6.7 29.3 YP_220552.1 NP_001373511.1 31.818 66 32 2 427 482 48 110 7.5 29.6 The problem with output format 6 is that you cant easily see the sequence description for the best hit, this could be really useful. But you do have a sequence identifier. You could rerun BLAST with the default output. But that could be extremely time consuming with large data sets. A better solution might be to search and extract the relavent information from the original refseq file. For this we can use grep. Grep is an essential unix command and can be extremely useful for quick file searching. Try running the following command; grep -n &quot;NP_059333.1&quot; /cloud/project/data/refseq/zebrafish.1.protein.faa &gt; /cloud/project/data/NP_059333.1_zebrafish.txt Here we are asking grep to look for lines containing the sequence identifier for the top hit in our BLASTp search, i.e.¬†\"NP_059333.1\", in our refseq zebrafish protein fasta file. Once found it grep will then copy and paste matching lines into a new text file within the data directory. The -n flag tells grep to also report the line number. Navigate to this newly made text file and use either less or head to view it. Compare the header information from our query and the top hit from our blast database. Do the results make sense? 3.3.4 BLASTn and BLASTx Try repeating the process with a new query. Use awk to extract lines 4121 and 4122 from the mouse nucleotide refseq files. Then useblastn to BLAST your new query against the zebrafish nucleotide database and create a new output file in output format 6 and use grep to extract the top hit from the zebrafish rna refseq file. Now you are confident with BLASTp and BLASTn we can start to have a look at BLASTx. Blastx is a great way to increase the power of your search, especially if you have an unknown sequence and are trying to work out which gene family it may belong to or if you are trying to identify protein coding genes. It takes a nucleotide query and translates the sequence using all six possible reading frames (so for all three possible codons and for both forward and reverse complement) and blasts the results against a protein database. You have been given an unknown nucleotide sequence from a Corydoras catfish species, /cloud/project/data/query/unknown_cory.fasta. Use the blastx and grep commands to try to work out what gene it most closely matches in zebrafish. 3.4 Formative quiz Use the workbook and outputs from the workshop to complete a quick online formative quiz. Go to the Genomes, Genes and Genomics blackboard page, Workshops and Practicals, Bioinformatics workshops to find the quiz. 3.5 Before you leave Today we have been building the beginnings of a bioinformatics toolkit. We have taken a look at .fastq and .fasta files and have started developing tips and tricks for working in the command line and using commonly used commands, packages and languages, including; Bash Awk Grep Blast To continue developing these skills there are some really awesome resources available with Astro Bio Mike at Happy Belly Bioinformatics One last thing, please to logout of RStudio Cloud before you leave. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
