[["index.html", "BIO-6013A/7004A, Bioinformatics Skills I and II Chapter 1 Introduction 1.1 Getting started", " BIO-6013A/7004A, Bioinformatics Skills I and II Philip Leftwich, Ellen Bell, Douglas Yu 2024-08-25 Chapter 1 Introduction This is a very short introduction to some of the processes and tools we use when working in bioinformatics. This is not meant to be comprehensive; you will be shown a few Unix fundamentals and one walk-through of a single bioinformatics task: using BLAST to identify nucleotide (DNA) and protein sequences. One of the main differences between Bioinformatics and the data analyses that you have done before is the size of the data. Bioinformatics usually deals with DNA sequencing data, which has large file sizes (measured in gigabytes and terabytes). Handling big data means you need to know how to operate on remote computing clusters, which nearly all run with the Unix operating system (you have probably only ever used Windows, MacOS, iOS, or ChromeOS computers, which are operating systems designed for personal computers). 1.1 Getting started These bioinformatics workshops will be run through RStudio in the Cloud, which is created by the company Posit. You should already have a free account at posit.cloud, following the instructions in the PDF (BIO-6013A Posit.cloud.pdf) that I posted previously on Announcements. After signing into Posit Cloud, join the workspace BIO 6013A with this link: https://posit.cloud/spaces/83242/join?access_code=KdnoYkm_NjGCQTX_BOlBC3bdBL99F8ePrbKJYHsX. First make an account on posit.cloud and Copy and paste the above link in your browser. Posit will ask you if you want to join the workspace. Say yes. You should now see two spaces: Your Workspace BIO-6013A Figure 1.1: Screen for when you first login to Posit Cloud Click on 6013A-Bioinformatics Skills I and II: Figure 1.2: Click on the 6013A-Bioinformatics Skills I and II workspace link This will create a copy of the RStudio project, and it should look something like this. Figure 1.3: Default RStudio workspace Go to Tools/Global Options and customise the workspace to look like this illustration. There are instructions on BIO-6013A Posit.cloud.pdf. Figure 1.4: Customisation of the RStudio workspace DON‚ÄôT worry if you don‚Äôt understand everything DO ask lots of questions! "],["Unix.html", "Chapter 2 Unix 2.1 What is Unix/Linux? 2.2 Why Learn Unix? 2.3 Getting started 2.4 A few foundational rules 2.5 Let‚Äôs get started 2.6 Unix File Structure 2.7 Absolute vs relative file paths 2.8 Moving around 2.9 Summary 2.10 Stretch yourself - optional extras to try a couple of other skills", " Chapter 2 Unix Unix is very likely the most fundamental skillset we can develop for bioinformatics (and beyond bioinformatics). Many of the most common and powerful bioinformatics approaches happen in this text-based environment, and having a solid foundation here can make everything we‚Äôre trying to learn and do much easier. This is a short introductory tutorial to help us get from being completely new to Unix up to being acquainted with it üôÇ. 2.1 What is Unix/Linux? UNIX is a computer operating system. It was first developed in 1969 at Bell Labs. Unix is written in the programming language C. Unix is proprietary software, whereas Linux is basically a free and open-source version of Unix. Most supercomputers run Linux. Operationally Linux is almost identical to Unix, and so we refer to it under the umbrella term of ‚Äúunix-like‚Äù systems. The ‚ÄòLi‚Äô in Linux is from the person who led its creation, Linus Torvalds. 2.1.1 Some terms Here are terms and concepts worth knowing. Term What it is shell The environment in which we communicate with a computer. A shell where you are pointing and clicking with a mouse is a¬†Graphical¬†User¬†Interface (GUI) shell. A shell with only text input and output is a¬†Command¬†Line¬†Interface (CLI) shell. A CLI shell has an associated programming language. server the computer where we host the data and programs that we are running. A server could be local, that is your own PC, or you could use a ‚Äòremote‚Äô server (a computer running in some other physical location), and you communicate with the remote server using your local PC. The reason to use a remote server is that they can be big computers that require a lot of power and cooling, which is most efficiently provided in specialised buildings. Another reason to use a remote server is that they can accommodate multiple users, and specialist administrators can be in charge of installing and maintaining one set of programs that are available to all users. bash the most common CLI shell used in unix-like OSs. the sh in bash stands for shell. You are using a combination GUI/CLI shell (called RStudio) running on your local PC to communicate with the Posit Cloud remote server, which runs R, bash, Python, C, and many, many programs that you link together with a series of commands, called a script. Thus, we say ‚ÄúWe write bash scripts to run on the Linux server.‚Äù terminal In the 1960s, the word terminal referred to TV+keyboard setups at the ends of long cables that were attached to a big ‚Äúmainframe‚Äù computer, usually in another room in the same building. The word terminal means ‚Äòend‚Äô. Now that we use the internet to connect to remote servers, which could be a continent away, the terminal is just an app on your personal computer that runs a CLI shell (mimicking the old TV+keyboard setups). Inside the RStudio GUI shell running locally on your PC, you will open multiple Terminals to communicate with different Posit Cloud servers. flag a way to set options for a function, a specific type of argument usually preceded by a - (a dash) Note You are familiar with using a GUI (Windows, iOS, Android, and MacOS are all GUIs), but to program a computer, you need to use a CLI (command line interface). 2.2 Why Learn Unix? Most sequencing data files are large and require a lot of computer memory (RAM) to process. As a result most of the work that bioinformaticians do is not hosted on their own laptops or desktops. Instead, they ‚Äúremote-connect‚Äù to high performance supercomputers or computer clusters. Almost all of these high performance computers use ‚ÄúUnix-like‚Äù operating systems, the most common of which is Linux. As stated above, Linux is free and open-source so there are lots of developers for it, which has helped Linux become stable, secure, reliable, and efficient. Today, you will get some experience with using a Linux OS. By logging into posit.cloud in your browser, you are connecting to the company Posit‚Äôs supercomputer, which runs Linux, and on top of Linux, Posit lets you run RStudio, which is a GUI for the statistics program called R. (Confusing? Yes. Linux is an operating system with a CLI shell, on which the RStudio GUI-shell runs, to make it easier to run the R language CLI shell.) When you click on RStudio‚Äôs Terminal tab, you get access to a Linux CLI bash shell, where you can execute commands and functions directly in Linux. (yes, now you have gone from RStudio‚Äôs GUI back to the Linux CLI). All these different shells give us the ability to use multiple programs &amp; programming languages. Note This series of practicals is designed for you to have a first introduction to Bioinformatics. It‚Äôs about exposure, not memorising or mastering anything. Don‚Äôt worry about the details! 2.3 Getting started Before we get started we need a terminal to work in. Click on the 6013A-Bioinformatics Skills I and II RStudio Project in your BIO-6013A workspace Click on the Terminal tab next to Console tab in the RStudio GUI. This opens a command-line Shell Figure 2.1: Here is an example of the Terminal tab, right next to the R console This is our ‚Äúcommand line‚Äù where we will be typing all of our commands. We type our commands in a language called bash The $ is where you start typing from, left of this it tells your working directory, which is the folder you are currently in. If you need to, you can exit the Terminal and start a new session. 2.4 A few foundational rules Spaces are special and break things apart. As a rule it is better to have functions and file names with dashes (-) or underscores (_) where you want space to be. Thus, ‚Äúdraft_v3.txt‚Äù refers to one file, while ‚Äúdraft v3.txt‚Äù refers to two files: draft and v3.txt. The general syntax on the bash command line is: command argument. Argument is a special term and it means all the extra text bits that customise your command. This is similar to R except we don‚Äôt use brackets e.g.¬†in R we put the arguments inside parentheses command(argument) Arguments can be optional e.g.¬†if their is a default argument you may not have to write anything. Some functions require that arguments are specified. Again this is just like R. 2.5 Let‚Äôs get started We will perform a very simple function and get a flavour of the similarities and differences to working in R. date is a command that prints out the date and time. Type date into your terminal This prints out the date/time in UTC format Figure 2.2: It should look like this: Now let‚Äôs add an argument to the date command to ask for the date next Tuesday. date is the command, and --date=\"next tue\" is the argument that causes the date command to modify its output. This argument is optional, as you have seen. Often, commands have required arguments. date --date=&quot;next tue&quot; The date command can do lots of things. You can learn more about about it here. Occasionally and alternatively, you set an environmental variable to get a command to function differently. For instance, we might want to tell the computer that we are in the London time zone. We do it this way: TZ=Europe/London date and if we want to find the time in Paris TZ=Europe/Paris date 2.5.1 Downloading data We will start by typing in an instruction to download data from an online data repository, unpack the contents, and inspect it. curl is a command line tool for transferring data to and from a remote computer server. Here we will use this to download data from an online repository called Figshare, and the -o argument sets the filename of the downloaded file (i.e.¬†you can choose what to name the downloaded file). tar unpacks and uncompresses the data from a tarballed and compressed file format. A compressed file format (known as gzipped) makes a large file smaller for download. A tarball format makes many individual files appear as one single file. In this example, you have downloaded a whole directory with over a hundred individual files, and Figshare has tarballed and compressed the directory so that it is easy to download. You therefore need a command to extract the files from the tarball and unzip the files Can you guess which two arguments of the four here tar -xzvf tell the computer to do these two things? rm removes the original downloaded file, which you had called unix_intro.tar.gz after untarballing and extracting, we have a new directory called unix_intro/. Can you find it in the Files tab of RStudio? ls -l lists the files in the working directory, and the -l asks for a particular format that I like. Can you see the new directory called unix_intro? cd changes your working directory so we land in the new folder we have made. # When we write the name of a directory in Unix, we have the option to add a / at the end of the name. This slash is only decorative, but it‚Äôs useful when you are reading bash scripts. Use the copy icon in the top right of the code block to copy all 3 commands and paste them into the Terminal. If this seems onerous to you, you are right. There is a keyboard shortcut for sending commands to the terminal. On Macs, it is opt-cmd-enter. On Windows, you can find the shortcut by opening Tools/Keyboard Shortcuts Help/ and looking for Send to Terminal under the Execute submenu. curl -L -o unix_intro.tar.gz https://ndownloader.figshare.com/files/15573746 tar -xzvf unix_intro.tar.gz rm unix_intro.tar.gz ls -l cd unix_intro/ Check each command line has run, in the example above you might find that the last line to change directory doesn‚Äôt run until you hit enter inside the Terminal 2.5.2 More functions Before the next step, make sure that you are in the unix_intro/ directory. You should see unix_intro$ in the command line. Unlike date, most commands require arguments and won‚Äôt work without them. head is a command that prints the first lines of a file, so of course it requires the filename: ls -l # do you see the file called example.txt? # if I precede a line with # (a hash), then bash knows to ignore it. This is how we can add comments inside a script head example.txt Here ‚Äúexample.txt‚Äù is the required argument, and in this case it is also what‚Äôs known as a positional argument. Whether things need to be provided as positional arguments or not depends on how the command or program we are using was written. Sometimes we need to specify the input file by putting something in front of it (e.g.¬†some commands will use the -i flag, but it‚Äôs often other things as well). Q. What‚Äôs in the text file? - Click here for Answer Pretty boring, each line contains the text ‚ÄúThis is line‚Äù followed by the line number e.g. - This is line 1 - This is line 2 etc. There are also optional arguments for the head command. The default for head is to print the first 10 lines of a file. We can change that by specifying the -n flag, followed by how many lines we want: head -n 20 example.txt How would we know we needed the -n flag for that? There are a few ways to find out. Many standard Unix commands and other programs will have built-in help menus that we can access by providing ‚Äìhelp as the only argument: head --help Well, as it happens, the command head does not have a help menu, but it still gives you some help when you try. Again this is very similar to the logic in which R commands are structured e.g.¬†?ggplot The syntax is similar even if the specific icons or arguments are different. Remember just like with R, one of your best friends is Google! As you get familiar with any language or OS we might remember a few flags or specific options, but searching for options and details when needed is definitely the norm! 2.6 Unix File Structure There are two special locations in all Unix-based systems: the ‚Äúroot‚Äù location and the current user‚Äôs ‚Äúhome‚Äù location. ‚ÄúRoot‚Äù is where the address system of the computer starts; ‚Äúhome‚Äù is usually where the current user‚Äôs location starts. Just to be awkward, Posit Cloud actually has us working in a different location ‚ÄúCloud‚Äù, which is underneath Root but separate to home which would be in the ‚ÄúUsers‚Äù folder. We tell the command line where files and directories are located by pre-pending the file name with the list of directories that hold them, known as the file‚Äôs ‚Äúpath‚Äù. If we use the pwd command (for print working directory), we can find out what the path is for the directory we are sitting in. Our working directory is also visible to the left of the $ in the command line pwd And if we use the ls -l command (for list), we can see what directories and files are in the current directory we are sitting in. (Note the -l argument) (also, try ls ‚Äì-help) (that‚Äôs 2 dashes in front of help) ls -l Note Why is it important to know this? Usually when you are working on a Unix-like environment there is no GUI (a click and point interface), and all commands have to be submitted through the terminal. So you have to get used to navigating directories with typed commands, and it‚Äôs useful to know what the standard hierarchy is and where you happen to be at any given moment. 2.7 Absolute vs relative file paths You should be used to these concepts from your work with R projects. There are two ways to specify the path (address) of the file we want to do something to: An absolute path is an address that starts from an explicitly specified location: usually the ‚Äúroot‚Äù / or the ‚Äúhome‚Äù ~/ location. (Side note, because we also may see or hear the term, the ‚Äúfull path‚Äù, is usually the absolute path that starts from the ‚Äúroot‚Äù /.) A relative path is an address that starts from wherever we are currently sitting (the working directory). For example, let‚Äôs look again at the head command we ran above: head example.txt What we are actually doing here is using a relative path to specify where the ‚Äúexample.txt‚Äù file is located. This is because the command line automatically looks in the current working directory if we don‚Äôt specify anything else about its location. We can also run the same command on the same file using an absolute path - note Posit Cloud has a slightly unique set-up in that we start from a folder called cloud: head /cloud/project/unix_intro/example.txt The previous two commands both point to the same file right now. But the first way, head example.txt, will only work if we are ‚Äúsitting‚Äù in the directory that holds that file, while the second way will work no matter where we happen to be in the computer. It is important to always think about where we are in the computer when working at the command line. One of the most common errors/easiest mistakes to make is trying to do something to a file that isn‚Äôt where we think it is. Let‚Äôs run head on the ‚Äúexample.txt‚Äù file again, and then let‚Äôs try it on another file: ‚Äúnotes.txt‚Äù: head example.txt head notes.txt Here the head command works fine on ‚Äúexample.txt‚Äù, but we get an error message when we call it on ‚Äúnotes.txt‚Äù telling us no such file or directory. If we run the ls command to list the contents of the current working directory, we can see the computer is absolutely right ‚Äì spoiler alert: it usually is ‚Äì and there is no file here named ‚Äúnotes.txt‚Äù. The ls command by default operates on the current working directory if we don‚Äôt specify any location, but we can tell it to list the contents of a different directory by providing it as a positional argument: ls -lF By running ls without each argument, can you understand what the -l and -F arguments are doing? ls -lF experiment We can see the file we were looking for is located in the subdirectory called ‚Äúexperiment‚Äù. Here is how we can run head on ‚Äúnotes.txt‚Äù by specifying an accurate relative path to that file: head experiment/notes.txt 2.8 Moving around We can also move into the directory containing the file we want to work with by using the cd command (change directory). This command takes a positional argument that is the path (address) of the directory we want to change into. This can be a relative path or an absolute path. Here we‚Äôll use the relative path of the subdirectory, ‚Äúexperiment‚Äù, to change into it cd experiment/ pwd ls -lF head notes.txt Great. But now how do we get back ‚Äúup‚Äù to the directory above us? One way would be to provide an absolute path, like cd /cloud/project/unix_intro, but there is also a handy shortcut. .. which are special characters that act as a relative path specifying ‚Äúup‚Äù one level ‚Äì one directory ‚Äì from wherever we currently are. So we can provide that as the positional argument to cd to get back to where we started: cd .. Moving around the computer like this might feel a bit cumbersome and frustrating at first, but after spending a little time with it, you will get used to it, and it starts to feel more natural. Note One way to speed things up is to start using tab to perform tab-completion often this will auto-complete file names! Press tab twice quickly and it will print all possible combinations. 2.9 Summary While maybe not all that exciting, these commands really are the foundation needed to start utilizing the command line ‚Äì which then gives us the capability to use lots of tools that only work at the command line to manipulate big data and to rapidly access and work with remote computers, and more! 2.9.1 Terms Term What it is path the address system the computer uses to keep track of files and directories root where the address system of the computer starts,¬†/ home where the current user‚Äôs location starts,¬†~/ absolute path an address that starts from a specified location, i.e.¬†root, or home relative path an address that starts from wherever we are tab-completion our best friend 2.9.2 Commands Command What it is date prints out information about the current date and time head prints out the first lines of a file pwd prints out where we are in the computer (print¬†working¬†directory) ls lists contents of a directory (list) cd change¬†directories 2.9.3 Special characters for the cd command Command What it is cd ~ go to your home directory cd .. go to one level above current (working) directory ls -lF . list files and directories in current directory. Normally, you don‚Äôt have to include the . character, but this is to let you know the meaning of the . dot. Some commands need you to say that you want to work on a file in this directory, and you use the dot to indicate that. In a single session, you won‚Äôt get used to operating in bash, or moving around directories using just the command line. So if you think you are interested in developing your bioinformatic skills, carve out a chunk of time to practise. Here is a link to a couple of extended tutorials you can bookmark if you want to explore this further: https://datacarpentry.org/shell-genomics/index.html 2.10 Stretch yourself - optional extras to try a couple of other skills 2.10.1 Creation I want to create a new directory, use mkdir to create a new directory called Code: Check you are in the unix_intro folder - Click on the arrow for Answer pwd Make a new directory called TEST inside unix_intro/ - Click on the arrow for Answer cd /cloud/project/unix_intro/ mkdir TEST Check this folder has been created using a list function ls -lF Note that I used a relative file path to create the TEST/ directory (because I first navigated to the location where i want the TEST/ directory) - but I could have also specified an absolute filepath to generate that folder in whatever location I want. There are a few ways to make new files on the command line. The simplest is to generate a blank file with the touch command followed by the path (relative or absolute) to the file you want to create Make a new text file inside the TEST/ directory, called data-science-class.txt - Click here for Answer touch TEST/data-science-class.txt ls -lF TEST/ Note here I could just use ls to list all files and folders in a directory, but if i set the flag -l then it will produce a long list of files. If the entry in the first column is a d, then the row in the table corresponds to a directory, otherwise the information in the row corresponds to a file. The string of characters following the d in the case of a directory or following the first - in the case of a file represent the permissions for that file or directory - I won‚Äôt cover that here - but some of the links I provide go into more detail. "],["BLAST.html", "Chapter 3 BLAST 3.1 Directories and their structure 3.2 File types 3.3 Basic Local Alignment Search Tool (BLAST) 3.4 Formative work 3.5 Before you leave", " Chapter 3 BLAST Lets take a moment to review some terminology. Unix - An operating system analogous with Windows. Shell - This is the interface we use to talk to the computer. If we are able to use the mouse to point and click we are using a Graphical User Interface (GUI). If we are only typing text commands, we are using a Command Line Interface (CLI). We will be using a CLI in these workshops. Command-line and Terminal - A text-based environment for sending commands to a computer‚Äôs operating system or to an application. The terminal is the app that gives you access to the operating system‚Äôs command line. It‚Äôs called terminal because there literally used to be a tv screen at the end (terminus) of a cable from a mainframe computer. bash - For the operating system to understand your commands, you need to follow a set of rules (known as a syntax), which collectively are known as a language. bash is one of these languages. When you write a series of bash-syntax commands, it is known as a bash script. Scripts are used to automate large amounts of bioinformatic work. Often, we use the term pipeline instead of script, because we think of bioinformatic work as moving data files from one transformation to the next, connected by pipes. In fact, bash has a pipe character that does exactly this: |. (This is not a number 1 or the capital letter I. It is a separate character on your keyboard. Make sure that you are working in the Terminal, where you will run commands in the bash language, and NOT in the Console, which is RStudio‚Äôs name for a special terminal that runs the R language. You will be running commands in the Terminal. (N.B. If RStudio goes to sleep and you resume it, RStudio will put you in the Console, not the Terminal, so you have to click on the Terminal tab to get back to the Terminal.) 3.1 Directories and their structure Working with text-based interfaces, where you are writing and running commands, means that we need to have some understanding of how files are organised within directories (‚Äúfolders‚Äù) and why it‚Äôs important to know which directory you are working in. Basically, you cannot open a file by pointing at it in a window. You need to write down the address to the file, which is known as the file‚Äôs path. To do that, you need to have a starting point for the path. Under Files in the bottom right panel of your screen you will see a file with the ending .Rproj. This is an R project file which tells R your starting point for navigating directories. It means that R will automatically treat the directory with the .Rproj file as the working directory. If you wish to access files outside of the working directory, you need to tell the program the file path to the file(s). Look at the top of the File panel. You will see the file path to whatever directory is active in the File tab. Figure 3.1: The current directory in this image is /cloud/project/images/, where I use the final / to indicate that images/ is a directory, not a file. In Posit.cloud, /cloud is the ‚Äòroot‚Äô directory. If a file‚Äôs path is written out all the way from the root, it is known as the absolute path, e.g./cloud/project/images/ascii.png 3.1.1 Moving around folders/directories Look in the ‚ÄòFiles‚Äô tab in the panel to the bottom right. You should have two directories stored there, called; code/ data/ plus some individual files, which are used during programming .gitignore .Rhistory project.Rproj (If you don‚Äôt see these files, click on the word ‚Äúproject‚Äù in ‚ÄúCloud &gt; project‚Äù near the top of the Files tab, and you should get there.) You can move around folders (=directories) in the command line, and it‚Äôs good to be comfortable doing this. Make sure you are in the Terminal tab in the panel to the bottom left and go to the /cloud/project directory with the cd command. (cdis shorthand for change directory, and remember to hit enter). cd /cloud/project Because we use /cloud/ at the beginning, we are using the absolute path to the project/ directory. Now list the files in this directory. ls -lF The ls command is shorthand for list, the -l argument means long listing format, and the -F argument means to classify the items by their type. Unix allows you to combine arguments into a single thing, to speed up typing. So ls -l -F is usually written as ls -lF. One way to think about Unix is that the commands are designed by people who like to use the command line but hate the act of typing, so all the commands are very short. If you get good at Unix, you will become like this. The terminal should return something that looks like this, and you will see that code/ and data/ are directories (because of the forward slashes). /cloud/project$ ls -lF total 12 drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 07:07 code/ drwxrwx--- 6 r574796 rstudio-user 4096 Sep 22 06:56 data/ -rw-rw-r-- 1 r574796 rstudio-user 205 Sep 22 11:07 project.Rproj Let‚Äôs go and have a look at the files held within data/. Use following command to navigate into data/; cd data # or cd data/ either syntax works. now your working directory is data/. List the files in this directory with ls -lF The terminal should return something that looks like this, showing four subdirectories underneath the data/ directory (which is itself a subdirectory of project/ /cloud/project/data$ ls -lF total 16 drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 blast/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 databases/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 query/ drwxrwx--- 2 r574796 rstudio-user 4096 Sep 22 06:56 refseq/ So you can see that you can use the commands cd and ls to move around and look inside your directories. Note - if you want to move back up a directory level you can use cd ... The two dots together .. means up in bash syntax, and you can also see the two dots at the top of the file list in the Files panel. If you click on those two dots, you also move up a directory level. Use cd, ls and cd .. to explore the directories available to you in your project. 3.1.2 Paths So hopefully you are starting to get comfortable moving between directories in the terminal. Here I will briefly introduce you to paths. Type in the following so that everyone is in the same location; cd /cloud/project/ If you want to enter some commands from this location that use the mouse.1.protein.faa file stored in the refseqdirectory, you will need to provide a path for the location of that file. These paths can either be absolute or relative. Relative paths provide a pathway from your current directory (which is currently /cloud/project/). So to get to the directory where your mouse.1.protein.faa file is you could use the following path; cd data/refseq However if you are currently, say, in the databases/ directory, this (relative) path won‚Äôt work because your computer will be looking for directories it can‚Äôt see. This is where absolute paths come in useful. Absolute paths specify the location of a file or directory starting from your root directory (the topmost directory). So it doesn‚Äôt matter which directory you are currently in, the absolute pathname will go to the right place. In this case the absolute path is: cd /cloud/project/data/refseq Have a go at using both absolute and relative paths with the cd command to move around your directories. 3.2 File types When we look at sequence data there are a number of file types that you will regularly come into contact with. The most common of these are .fastq and .fasta files, which are appended to filenames as suffixes. This is purely for your convenience. You could have a different suffix, or even no suffix, but if you do, you will confuse yourself and others as to the content and format of your files, so that‚Äôs why we use filename suffixes. Here we will have a look at some key features and differences of these file types. Fastq files are used as a data storage file for the output from Illumina sequencers. The structure of a .fastq file is very uniform. Each DNA sequence has four lines dedicated to it. Line 1 - begins with an ‚Äò@‚Äô character and is followed by an identifier and optional description. It contains information about the sequencer, the flow cell, index number, the precise location within the flow cell where the sequence comes from, etc. The identifier is unique to each sequence. Line 2 - is the DNA sequence Line 3 - a ‚Äò+‚Äô character (and sometimes a repeat of line 1) Line 4 - computer-readable information relating to the quality of each nucleotide in the sequence in line 2. Therefore, there are as many quality characters as sequence characters. The letters indicate the probability of error and are known as phred scores, coded as ASCII characters. For example, the phred ASCII code A translates to a score of 32, which means that there is a \\(1/1585\\) probability that the nucleotide G is incorrect See https://en.wikipedia.org/wiki/Phred_quality_score and https://support.illumina.com/help/BaseSpace_OLH_009008/Content/Source/Informatics/BS/QualityScoreEncoding_swBS.htm An example of three sequences from an Illumina sequencer in fastq format is shown below. Note that there is no empty line between the three sequences. @NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT GCATGTCTCTAGTTCCGGAACCAAAATCTCCTCCACCCACTCTGCGTCCTGCTGACTATAGGAGATAAAGGCGTCATAGCAGAGGGTGGCGCCTCCTTGGTGCACCGCCGGCTTTCGCTTCGCCTTAAACCAGGCGACGGACATTTTCAGG + AAAAAEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEAEEEEEEEEEAEEEEEEEEEEEEEEAAEEEEEEEEEAAEE&lt;AEEEEEEEEEEEEEEEEEEAEEEEEEE&lt;EA @NB501793:9:H77L2BGX2:1:11101:24170:10019 1:N:0:ATCACGAT GCATGTCAACATCATTCTTGTTTTGTTAGAGCCACTACCTACATATCTTATCCCTTCCAAGTACTACCAGCTAAAGGCAATGATACATGC + AAAAAEA/EEEE/EEEEEEEEEEEAEEEEEEEEEEEEEEEEEEEEEAEAEAEEEAEEEEEEEEEEEEEEAEEE/EEEEEEAE/E/AEEAE @NB501793:9:H77L2BGX2:1:11101:7027:14110 1:N:0:ATCACGAT GCATGTGATGTTGTGTTTTTGTACTCTCCTCTCACTTTGTCCAAAGTGAGTGGTGTCATTATGAGTTGTATTTTGCTAACCACCAGAGACTAACACGAGGGCTGGACAACATCATTCTAGTTTTGTTAGAGCCACTACCTACATATC + AAA/AEEEEEEEEEEEEEEEEAEAAEEEEAAEEEEEEE/EEEAEEEEA/EE6EEEEEEEEEEEE6EE/EAEEE/EEEAAEAEEE/EEEEEE6EEEAE/&lt;EAEEEEEE/EEAEEAE&lt;E//AE&lt;&lt;/EAEA//&lt;&lt;&lt;A6AE/EEEE/A/EA Fasta files are a simpler (and thus smaller) text-based file format for representing both nucleotide and amino acid sequences. These can be produced from fastq files (However, fastq files cannot be produced from fasta files; comparing the two formats (above and below), can you figure out why?). Each sequence in .fasta format comes with a header line which is marked by a ‚Äò&gt;‚Äô character prefix. Information following the ‚Äò&gt;‚Äô typically contains a sequence identifier and an optional description of the sequence. A lot of bioinformatic programming adds and subtracts information from the fasta header line. An example of three sequences from an Illumina sequencer in .fasta format is shown below. You may notice that these are the same sequences as shown above in the fastq example; typically, the header lines in fasta files are more human-readable (i.e.¬†not &gt;NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT) &gt;NB501793:9:H77L2BGX2:1:11101:26113:7113 1:N:0:ATCACGAT CTCTAGTTCCGGAACCAAAATCTCCTCCACCCACTCTGCGTCCTGCTGACTATAGGAGATAAAGGCGTCATAGCAGAGGGTGGCGCCTCCTTGGTGCACCGCCGGCTTTCGCTTCGCCTTAAACCAGGCGACGGACATTTTCAGG &gt;NB501793:9:H77L2BGX2:1:11101:24170:10019 1:N:0:ATCACGAT CAACATCATTCTTGTTTTGTTAGAGCCACTACCTACATATCTTATCCCTTCCAAGTACTACCAGCTAAAGGCAATGATACATGC &gt;NB501793:9:H77L2BGX2:1:11101:7027:14110 1:N:0:ATCACGAT GATGTTGTGTTTTTGTACTCTCCTCTCACTTTGTCCAAAGTGAGTGGTGTCATTATGAGTTGTATTTTGCTAACCACCAGAGACTAACACGAGGGCTGGACAACATCATTCTAGTTTTGTTAGAGCCACTACCTACATATC Now, let‚Äôs have a look at your data. The /cloud/project/data/refseq directory contains files downloaded from the NCBI Reference Sequence project. These files comprise a set of transcript and protein sequences for the mouse and zebrafish model systems and were downloaded from the NCBI. Use your newfound command line tools to move into the refseq directory. When you run ls -lFh you should see the following: Figure 3.2: Using the extra argument -h makes the file sizes human readable. Use the head command to have a look at the first few lines of each of the four files stored in refseq. An example of the head command‚Äôs usage is as follows; head mouse.1.protein.faa What differences do you notice about the four files? Do you think these are .fastq or .fasta files? You might have noticed the two file suffixes (also known as file extensions): .faa and .fna. These file suffixes tell you something about the content of the file. Can you work out what .faa and .fna mean? That ends our review of Unix. Now let‚Äôs do something bioinformatics-y! 3.3 Basic Local Alignment Search Tool (BLAST) The acronym BLAST stands for Basic Local Alignment Search Tool. It is a very versatile and useful program, frequently used in bioinformatic analysis to find close (and not-so-close) nucleotide or protein sequence matches in a database. It has a range of uses, including assisting in the identification of sequences and assessing evolutionary relationships between sequences. There are different types of BLAST that work with nucleotide or amino acid input sequences. You might have previously uploaded sequences to the NCBI website and used their BLAST tool from a web browser. Running BLAST on the NCBI website compares your query sequence against the entirety of GenBank, which is enormous. Here we will run BLAST from the command line against a local database. 3.3.1 Making a BLAST database In order to run BLAST, we first need to make some suitable BLAST databases. Initially we will be using sequences from our mouse refseq files as queries to ‚Äúblast against‚Äù databases made from our zebrafish refseq files. So let‚Äôs convert our refseq zebrafish files into blast databases. Run the following command in the terminal; {bash} cd /cloud/project makeblastdb -in /cloud/project/data/refseq/zebrafish.1.rna.fna -dbtype nucl -title zebrafish.1.rna -out /cloud/project/data/databases/zebrafish.1.rna Take a moment to break down this command. The command is makeblastdb. The first argument -in tells makeblastdbwhich file(s) you want to turn into a database. You chose to indicate the file with an absolute pathname, which means that you can run the command from anywhere in the computer and still find the file. You have also given instructions on what type of database you wish to produce (i.e.¬†a nucleotide database) using the argument -dbtype nucl and finally indicated where you want the output database to be stored, using the argument -out /cloud/project/data/databases/zebrafish.1.rna, again using an absolute pathname. Note that one of things you have to think about constantly is file naming. My preference is for longer filenames that explain what a file contains and what happened to it. Sometimes it helps to write and read a command vertically so that you can see all the arguments (debugging is easier too). Unfortunately, you can‚Äôt copy and paste the command like this. makeblastdb -in /cloud/project/data/refseq/zebrafish.1.rna.fna -dbtype nucl -title zebrafish.1.rna -out /cloud/project/data/databases/zebrafish.1.rna After running the command, use the cd and ls commands to go to /cloud/project/data/databases/ and have a look at the new files stored there. There should be three files all starting with zebrafish.1.rna, and they should have .nhr, .nin, .nsq file extensions. This is how BLAST likes to store its databases. Now try and make a similar database for the zebrafish.1.protein.faa refseq file. You will need to instruct makeblastdb to make a prot (protein) database instead of a nucl database. Check your results in /cloud/project/data/databases/. Once again there should be three files, and they should have .phr, .pin and .psq file extensions. Q. What is the command? - Click here for Answer makeblastdb -in /cloud/project/data/refseq/zebrafish.1.protein.faa -dbtype prot -title zebrafish.1.protein -out /cloud/project/data/databases/zebrafish.1.protein 3.3.2 Finding a query So hopefully you have a protein and a nucleotide database prepared. Now we need to decide on suitable query sequences. We could use an entire mouse refseq file as our set of query sequences, but that would take a long time because the refseq file contains many sequences. Instead, let‚Äôs take a single entry from the mouse protein refseq file instead. We do this in the command line with the Unix utility program awk, which is used for querying and extracting rows from tabular data files. In bioinformatics, it is frequently used for filtering sequence files. For now, I would like you to use the awk command below; this will copy lines 5 and 6 of the mouse.1.protein.faa file and paste them in a new file called mouse.1.protein.1.faa in the query directory. awk &#39;NR==5 , NR==6&#39; /cloud/project/data/refseq/mouse.1.protein.faa &gt; /cloud/project/data/query/mouse.1.protein.1.faa Use head to look at the contents of the mouse.1.protein.1.faa file in the query directory. It should look like this; &gt;YP_220552.1 cytochrome c oxidase subunit I (mitochondrion) [Mus musculus domesticus] MFINRWLFSTNHKDIGTLYLLFGAWAGMVGTALSILIRAELGQPGALLGDDQIYNVIVTAHAFVMIFFMVMPMMIGGFGNWLVPLMIGAPDMAFPRMNNMSFWLLPPSFLLLLASSMVEAGAGTGWTVYPPLAGNLAHAGASVDLTIFSLHLAGVSSILGAINFITTIINMKPPAMTQYQTPLFVWSVLITAVLLLLSLPVLAAGITMLLTDRNLNTTFFDPAGGGDPILYQHLFWFFGHPEVYILILPGFGIISHVVTYYSGKKEPFGYMGMVWAMMSIGFLGFIVWAHHMFTVGLDVDTRAYFTSATMIIAIPTGVKVFSWLATLHGGNIKWSPAMLWALGFIFLFTVGGLTGIVLSNSSLDIVLHDTYYVVAHFHYVLSMGAVFAIMAGFVHWFPLFSGFTLDDTWAKAHFAIMFVGVNMTFFPQHFLGLSGMPRRYSDYPDAYTTWNTVSSMGSFISLTAVLIMIFMIWEAFASKREVMSVSYASTNLEWLHGCPPPYHTFEEPTYVKVK Note that refseq.fasta has a .fasta file suffix, and when you look inside, it indeed has been formatted as a fasta file, so that each entry has two lines: one header line, one sequence line. (yes, the sequence is one line; it just wraps around) This means odd numbered lines are headers and even numbered lines are the corresponding sequences. Note that bioinformaticians have written lots of utility programs that let us query, extract, and edit sequence files and are easier to use than the base Unix programs likeawk, grep, and sed. But even so, i often find myself using basic Unix utility programs. 3.3.3 BLASTp Now that we have prepared a query and database we can start to run some BLASTs. Our query is from the protein refseq files, so we will run BLASTp against the protein zebrafish database. Run the following command; blastp -query /cloud/project/data/query/mouse.1.protein.1.faa -db /cloud/project/data/databases/zebrafish.1.protein -out /cloud/project/data/blast/mouse.1.protein.x.zebrafish.txt It is helpful to read this command without the long pathnames and written vertically. There are three arguments: -query, -db, and -out blastp -query mouse.1.protein.1.faa -db zebrafish.1.protein -out mouse.1.protein.x.zebrafish.txt Take a look at the default output from this BLAST search, use: less /cloud/project/data/blast/mouse.1.protein.x.zebrafish.txt less is yet another Unix utility program that lets you look at portions of really long files (see less than the whole). Type Enter to scroll through the file, and use q when you‚Äôre ready to quit. You will see that this default output contains a lot of information, including information relating to significant database hits, significance scores and alignments. We only have three hits here, so its easy enough to process in this format, but sometimes you may have much larger outputs. In this case a tabular format is much more desirable. Try running the following command; (Remember to have typed q to get out of the less command. You need to be back at the command line.) blastp -query /cloud/project/data/query/mouse.1.protein.1.faa -db /cloud/project/data/databases/zebrafish.1.protein -out /cloud/project/data/blast/mouse.1.protein.x.zebrafish.2.tsv -outfmt 6 Now we have added one more argument: -outfmt 6, which means output format number 6. Use head to have a look at this new presentation of information (remember to include the correct path). The output this time is a tabular format, which is much easier to process quickly especially when you are looking at large data sets. I have pasted a bit of the output you should be looking at below with the column headers added. You can read all about output format 6 here. qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore YP_220552.1 NP_059333.1 88.132 514 61 0 1 514 1 514 0.0 877 YP_220552.1 XP_021326074.1 31.818 66 32 2 427 482 16 78 6.7 29.3 YP_220552.1 NP_001373511.1 31.818 66 32 2 427 482 48 110 7.5 29.6 Your query sequence is YP_220552.1, and it matched three sequences in the protein database. The topmost row is the best match, which you can tell by reading the second-to-last (evalue) and last (bitscore) columns. evalue is the probability of getting a match this good in a random database of the same size. Here, evalue has been rounded to 0.0, which just means that the probability is very small (but not strictly 0). The bitscore value is the ‚Äúsize of a random sequence database in which the current match could be achieved just by chance‚Äù. In this case, the bitscore number is high (877), and the database size is \\(2^{877}\\), which is astronomically high. To have a random sequence match your query sequence this well, you would have needed a gigantic random sequence. In short, the topmost reference sequence, NP_059333.1, is a really good match to your query sequence, YP_220552.1. See here for more details on evalue and bit score. The problem with output format 6 is that you can‚Äôt see any additional information about your reference sequence NP_059333.1. But since you now have the reference sequence identifier, you can search and extract the relevant information from the original refseq file. For this we can use grep, which is the Unix equivalent of the Find function in your word processor. Try the following command: grep -n &quot;NP_059333.1&quot; /cloud/project/data/refseq/zebrafish.1.protein.faa &gt; /cloud/project/data/NP_059333.1_zebrafish.txt Here we are asking grep to look for lines containing the sequence identifier NP_059333.1 in our refseq zebrafish protein fasta file. Once found, grep puts those lines into a new text file within the data directory NP_059333.1_zebrafish.txt. The -n flag tells grep to also report the line number. Q. How did we tell grep to put the output in a new file? - Click here for Answer We used the &gt; character, which is known as a redirect character. It is redirecting, because if you hadn‚Äôt used &gt; /cloud/project/data/NP_059333.1_zebrafish.txt, grep would have sent the output to the standard place, which is the screen. Navigate to this newly made text file and use either less or head to view it. Compare the header information from our query and the top hit from our blast database. Do the results make sense? Q. What species does the sequence come from? - Click here for Answer 209:&gt;NP_059333.1 cytochrome c oxidase subunit I (mitochondrion) [Danio rerio] (Thus, the species is Danio rerio, which is the zebrafish.) 3.3.4 BLASTn and BLASTx Try repeating the process with a new query. Use awk to extract lines 4121 and 4122 from the mouse nucleotide refseq files (Q: how many sequences do you get when you extract 2 lines?). Then use blastn (not blastp!) to BLAST your new query against the zebrafish nucleotide database and create a new output file in output format 6 and use grep to extract the top hit from the zebrafish RNA refseq file. Q. Write the code first and then check here. # preceding text with a hashtag tells programs like bash and R not to try to run the text as a command. # mouse awk &#39;NR==4121, NR==4122&#39; /cloud/project/data/refseq/mouse.1.rna.fna &gt; /cloud/project/data/query/mouse.1.rna.query.fna blastn -query /cloud/project/data/query/mouse.1.rna.query.fna -db /cloud/project/data/databases/zebrafish.1.rna -out /cloud/project/data/blast/mouse.1.rna.query.zebrafish.1.tsv -outfmt 6 head /cloud/project/data/blast/mouse.1.rna.query.zebrafish.1.tsv # the top hit sequence is: NM_001347668.1 grep -n &quot;NM_001347668.1&quot; /cloud/project/data/refseq/zebrafish.1.rna.fna &gt; /cloud/project/data/NM_001347668.1_zebrafish.txt head /cloud/project/data/NM_001347668.1_zebrafish.txt # 111407:&gt;NM_001347668.1 Danio rerio thyroid hormone receptor interactor 12 (trip12), mRNA # in other words, the mouse nucleotide sequence is most similar to the zebrafish thyroid hormone receptor interactor 12 (trip12) gene, which gives you a clue as to the function of the mouse gene. Now you are confident with BLASTp and BLASTn, we can look at BLASTx. blastx is a great way to increase the power of your search, especially if you have an unknown sequence and are trying to work out which gene family it may belong to or if you are trying to identify protein coding genes. It takes a nucleotide query and translates the sequence using all six possible reading frames (so all three possible codons for both forward and reverse complement) and blasts the results against a protein database. 3.4 Formative work 3.4.1 Write a blastx query You have been given an unknown nucleotide sequence from a Corydoras catfish species, /cloud/project/data/query/unknown_cory.fasta. Use the blastx and grep commands to try to work out what gene it most closely matches in zebrafish. Q. Write the code first and then check here. # Corydoras # with blastx, the query sequence is a nucleotide sequence, but the reference database is of amino acids (proteins) blastx -query /cloud/project/data/query/unknown_cory.fasta -db /cloud/project/data/databases/zebrafish.1.protein -out /cloud/project/data/blast/unknown_cory.protein.x.zebrafish.1.tsv -outfmt 6 head /cloud/project/data/blast/unknown_cory.protein.x.zebrafish.1.tsv # NB501793:9:H77L2BGX2:1:11101:9692:2734 NP_001124065.1 85.714 42 6 0 1 126 690 731 1.06e-20 83.6 # the top hit is NP_001124065.1 grep -n &quot;NP_001124065.1&quot; /cloud/project/data/refseq/zebrafish.1.protein.faa &gt; /cloud/project/data/NP_001124065.1_zebrafish.txt head /cloud/project/data/NP_001124065.1_zebrafish.txt 3.4.2 Formative quiz Use the workbook and outputs from the workshop to complete a quick online formative quiz. Go to the Genomes, Genes and Genomics Blackboard page, Formative assessments, Bioinformatics Workshop 1 Quiz - BLAST to find the quiz. 3.5 Before you leave Today we have been building the beginnings of a bioinformatics toolkit. We have taken a look at .fastq and .fasta files and have started learning commands for working in the command line and using commonly used commands, packages and languages, including; cd, ls head, less awk grep makeblastdb, blastp, blastn, blastx To continue developing these skills there are some really awesome resources available with Astro Bio Mike at Happy Belly Bioinformatics One last thing, please log out of Posit Cloud before you leave. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
